import{_ as o,p as c,q as p,w as i,s as n,R as s,t as e,Y as t,n as l}from"./framework-aa5c4115.js";const r={},d=n("p",null,"变量赋值，引用类型、对象在内存中的存储都与拷贝相关",-1),u=t(`<h1 id="浅拷贝和深拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝和深拷贝" aria-hidden="true">#</a> 浅拷贝和深拷贝</h1><p>JavaScript类型分为<code>普通类型</code>和<code>复杂类型</code>，普通类型也成为原始类型，复杂类型指 <code>Object</code> 和 <code>Symbol</code>。 原始类型有：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>undefined</li><li>null</li><li>BigInt:一种比number更大的整数</li></ul><h2 id="浅拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝" aria-hidden="true">#</a> 浅拷贝</h2><p>变量之间传值，通过 “=” 将值进行传递，以原始类型为例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span>  b <span class="token operator">=</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1,1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量<code>b</code>成功将<code>a</code>的值复制并且赋值给自身，但它们都是独立的，如果改变b的值，<code>a</code> 的值不会随之改变。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>b <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1,2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上诉就是浅拷贝行为，复制的不是变量本身而是变量所赋的值。</p><p>通常来说，原始类型之间的复制都是浅拷贝行为，但是复杂类型之间的拷贝就不是如此。对象所存储的是对象的内存地址，一个变量赋值对象，变量本身会赋值给对象的地址，也就是对象的引用。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;lbw&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span>  b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//{name: &#39;hi&#39;} {name: &#39;hi&#39;}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现属性<code>name</code> 的修改不仅影响了变量 <code>b</code> 赋值的对象也影响了 <code>a</code>，这就说明变量 <code>b</code> 复制了变量 <code>a</code>的引用，而该对象自身并没有被复制。</p><h2 id="深拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a> 深拷贝</h2><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p>`,14),v={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign",target:"_blank",rel:"noopener noreferrer"},k=n("code",null,"对象扩展运算符",-1),m=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;lbw&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">info</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span>  b <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>a
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//或者</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//修改克隆对象</span>
b<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span>info<span class="token punctuation">.</span>age <span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
a : {
	info: {age: 111}
	name: &quot;lbw&quot;
}
b : {
	info: {age: 111}
	name: &quot;hi&quot;
}
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>克隆变量<code>b</code> 修改引用类型<code>info</code>会导致原始变量一同发生变化</p><h3 id="json-stringify" tabindex="-1"><a class="header-anchor" href="#json-stringify" aria-hidden="true">#</a> JSON.stringify()</h3><p>这种方法十分常用，我在处理接口的时候十分依赖这个函数，原理是将对象序列化转化为字符串，之后将字符串进行传输，另一个终端通过JSON.parse()方法反序列化将JSON字符串变成一个新的对象。这种方法具有许多缺陷比如拷贝其他引用类型、拷贝函数、循环引用等情况。</p><blockquote><ul><li><p>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</p></li><li><p>无法拷贝不可枚举的属性，无法拷贝对象的原型链</p></li><li><p>拷贝Date引用类型会变成字符串</p></li><li><p>拷贝RegExp引用类型会变成空对象</p></li><li><p>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</p></li><li><p>无法拷贝对象的循环应用(即obj[key] = obj)</p></li></ul></blockquote>`,5),b={class:"custom-container details"},h=n("summary",{class:"custom-container-title"},"参考文献",-1),g={href:"https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&mid=2247490151&idx=1&sn=ba6b57ca70ad91d3e48aacc8e9019604&chksm=c2e2ef4cf595665a43cf7c0cc203f9b4cd9ac1529e8e8dfad076429a02c40ae959c1dbcc3c14&token=254251558&lang=zh_CN#rd",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.jianshu.com/p/c651aeabf582",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zh.javascript.info/object-copy#cloning-and-merging-object-assign",target:"_blank",rel:"noopener noreferrer"},y={href:"https://developer.mozilla.org/zh-CN/",target:"_blank",rel:"noopener noreferrer"};function j(w,x){const a=l("ExternalLinkIcon");return c(),p("div",null,[d,i(" more "),u,n("p",null,[s("使用"),n("a",v,[s("Object.assign()"),e(a)]),s(" 和 "),k,s("都是浅拷贝，这两个方法都会让你觉得对象被深拷贝了，但如果你在原型对象里添加一个引用类型，你会发现引用类型被浅拷贝了，原始类型被深拷贝了！")]),m,n("details",b,[h,n("p",null,[n("a",g,[s("如何写出一个惊艳面试官的深拷贝 (qq.com)作者：code秘密花园"),e(a)])]),n("p",null,[n("a",_,[s("对象深拷贝和浅拷贝 - 简书 (jianshu.com)作者：心_c2a2"),e(a)])]),n("p",null,[n("a",f,[s("对象引用和复制 (javascript.info)"),e(a)])]),n("p",null,[n("a",y,[s("MDN Web Docs (mozilla.org)"),e(a)])])])])}const S=o(r,[["render",j],["__file","Shallow copy and deep copy.html.vue"]]);export{S as default};
